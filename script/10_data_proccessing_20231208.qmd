---
title: "WT:WP1:Paper 1"
format:
  html:
    code-fold: true
    code-summary: "Show the code"
    code-link: true
    embed-resources: true
    page-layout: full
    grid:
      sidebar-width: 200px
      margin-width: 200px
      body-width: 1100px
author: Daniel Väisänen
editor:
  markdown: 
    wrap: sentence
toc: true
toc-depth: 2
toc-location: left
toc-expand: true
execute: 
  warning: false
  echo: true
  freeze: auto
highlight-style: custom.theme
theme:
  light: github
  dark: darkly
---
# Project description

Paper 1 in work project 1 of the work together series

#-------------------------
## Libraries

```{r}
xfun::pkg_attach(
  "tidyverse", 
  "dtrackr", 
  "glue", 
  "DT", 
  "flextable"
  )

```
#-------------------------
## Base theme

```{r}
# theme_set(
#   theme_minimal(
#     base_size = 16,
#     base_family = "Roboto"
#   ) +
#     theme(
#       legend.position = "top",
#       panel.grid.major.y = element_blank(),
#       panel.grid.minor.y = element_blank(),
#       panel.grid.major.x = element_blank(),
#       panel.grid.minor.x = element_blank(),
#       axis.title.y = element_blank(),
#       axis.title.x = element_blank()
#     )
# )


```

#-------------------------
## Data

```{r}
hpa <- read_csv(here::here("..", "..","..", "HPI (DNR XXXXXX)", "Data HPI registeruttag 2023", "HPI", "HPI clean", "EEB_hpb_clean_2023-10-16.csv")) %>% 
    mutate(SymptomBackNeck = if_else(SymptomBackNeck == 7 | SymptomBackNeck == 8, NA, SymptomBackNeck)) 

scb <- read_csv(here::here("..", "..","..", "HPI (DNR XXXXXX)", "Data HPI registeruttag 2023", "SCB", "SCB clean", "Grunduppgifter_2023-09-24.csv")) %>% mutate(Kommun=str_replace(Kommun, "^0+", ""))# remove leading zeros

# join SCB and HPI data
df <- hpa %>% inner_join(scb, by = join_by(LopNr, Performed, Year))  %>% 
    mutate(SSYK1_scb_hpi_combined = coalesce(SSYK1, Ssyk1_hpi_combined))

```


# Selection
different n depending on different selection criterias
```{r, eval=FALSE}

# Assuming 'hpa' is your original data frame
# Calculate base counts
base_counts <- hpa %>% 
  arrange(LopNr, Performed) %>% 
  mutate(hpa_number = row_number(), .by = LopNr) %>% 
  count(hpa_number) %>% 
  slice_head(n = 10) %>%
  rename(base_count = n)

# Calculate counts for different conditions
hpa_counts <- hpa %>% 
  arrange(LopNr, Performed) %>% 
  mutate(hpa_number = row_number(), .by = LopNr)

# Function to filter and count based on minimum number of non-NA values
count_non_na <- function(data, phys_min, quest_min) {
  data %>% 
    filter(
      rowSums(!is.na(select(., starts_with("EkB_rel_VO2"), starts_with("Astrand_rel_VO2"), 
                             starts_with("HeightCM"), starts_with("WeightKG"), 
                             starts_with("BloodPressureSystolic"), starts_with("BloodPressureDiastolic")))) >= phys_min,
      rowSums(!is.na(select(., starts_with("ExerciseAnswer"), starts_with("TobaccoSmoking"), 
                             starts_with("Diet"), starts_with("Health"), 
                             starts_with("StressOverall"), starts_with("SymptomBackNeck")))) >= quest_min,
      Year > 1994
    ) %>% 
    count(hpa_number) %>% 
    slice_head(n = 10) %>%
    # Create a column with a dynamic name based on phys_min and quest_min
    mutate("{paste0('n', phys_min, '_', quest_min)}" := n) %>%
    select(-c(hpa_number, n))
}

# Apply the function with different minimum values
counts_1_1 <- count_non_na(hpa_counts, 1, 1) 
counts_1_2 <- count_non_na(hpa_counts, 1, 2)
counts_2_1 <- count_non_na(hpa_counts, 2, 1)
counts_2_2 <- count_non_na(hpa_counts, 2, 2)
counts_3_2 <- count_non_na(hpa_counts, 3, 2)
counts_2_3 <- count_non_na(hpa_counts, 2, 3)
counts_3_3 <- count_non_na(hpa_counts, 3, 3)

# Join all counts together
sums <- bind_cols(base_counts, counts_1_1, counts_1_2, counts_2_1, counts_2_2, counts_3_2, counts_2_3, counts_3_3) 
  

sums %>%
  mutate(
    diff_1_1 = base_count - n1_1,
    ande_1_1 = (diff_1_1 / base_count) * 100,
    diff_1_2 = base_count - n1_2,
    ande_1_2 = (diff_1_2 / base_count) * 100,
    diff_2_1 = base_count - n2_1,
    ande_2_1 = (diff_2_1 / base_count) * 100,
    diff_2_2 = base_count - n2_2,
    ande_2_2 = (diff_2_2 / base_count) * 100,
    diff_3_2 = base_count - n3_2,
    ande_3_2 = (diff_3_2 / base_count) * 100,
    diff_2_3 = base_count - n2_3,
    ande_2_3 = (diff_2_3 / base_count) * 100,
    diff_3_3 = base_count - n3_3,
    ande_3_3 = (diff_3_3 / base_count) * 100
  ) %>% select(-starts_with("n")) %>% 
  mutate(across(everything(), round(1))) %>% 
  flextable::flextable()




```



  
# Variable creation
d <-pxweb:: pxweb_interactive()
```{r}
# data from tillväxtverket, another possibility could be skr
metropolitan_municipalities <- c("114", "123", "126", "127", "128", "136", "138", "139", "160", 
                                 "162", "163", "180", "181", "182", "183", "184", "186", "191", 
                                 "1230", "1231", "1262", "1280", "1281", "1402", "1480", "1481")

dense_municipalities <- c("115", "117", "120", "140", "187", "305", "330", "380", "381", "461", 
                          "480", "481", "483", "484", "486", "561", "562", "580", "581", "583", 
                          "584", "642", "643", "680", "682", "683", "686", "687", "760", "765", 
                          "780", "781", "880", "881", "882", "883", "884", "1060", "1080", "1082", 
                          "1233", "1261", "1263", "1272", "1275", "1282", "1277", "1282", "1283", 
                          "1285", "1286", "1287", "1290", "1292", "1380", 
                          "1382", "1401", "1407", "1440", "1441", "1472", "1482", "1484", "1485", 
                          "1486", "1487", "1488", "1489", "1490", "1492", "1493", "1494", "1495", 
                          "1496", "1497", "1498", "1499", "1715", "1761", "1780", "1781", "1782", 
                          "1784", "1785", "1862", "1880", "1881", "1883", "1884", "1907", "1960", 
                          "1961", "1980", "1981", "1982", "1983", "1984", "2062", "2080", "2081", 
                          "2085", "2104", "2180", "2181", "2262", "2280", "2281", "2380", "2523", "2580", "2581", 
                          "2582", "2583", "2584")

rural_municipalities <- c("125", "128", "188", "192", "319", "331", "360", "382", "428", "482", "488", "509", 
                          "512", "513", "560", "563", "580", "582", "586", "604", "617", "662", "665", 
                          "684", "685", "761", "763", "764", "767", "821", "834", "840", "860", "861", "862", "885", 
                          "980", "1081", "1083", "1214", "1256", "1257", "1260", "1264", "1265", 
                          "1266", "1267", "1270", "1273", "1276", "1278", "1284", "1291", "1293", "1315", 
                          "1381", "1383", "1384", "1415", "1419", "1421", "1427", "1430", "1435", 
                          "1438", "1439", "1442", "1443", "1444", "1445", "1446", "1447", "1452", 
                          "1460", "1461", "1462", "1463", "1465", "1466", "1491", "1470", "1471", "1473", 
                          "1730", "1737", "1760", "1762", "1763", "1764", "1765", "1766", "1783", "1814", 
                          "1860", "1861", "1863", "1864", "1882", "1885", "1904", "1962", "2021", 
                          "2023", "2026", "2029", "2031", 
                          "2034", "2039", "2061", "2082", "2083", "2084", "2101", "2121", "2132", 
                          "2161", "2182", "2183", "2184", "2260", "2282", "2283", "2284", "2303", 
                          "2305", "2309", "2313", "2321", "2326", "2361", "2401", "2403", "2404", 
                          "2409", "2417", "2418", "2421", "2422", "2425", "2460", "2462", "2463", 
                          "2480", "2481", "2482", "2505", "2506", "2510", "2513", "2514", "2518", 
                          "2521", "2560")






df1 <- df %>% 
   mutate(Kommun=str_replace(Kommun, "^0+", "")) %>% 
  # Convert Year to date and create 5-year periods
  mutate(Period = case_when(
    Year >= 1995 & Year < 2000 ~ "1995-1999",
    Year >= 2000 & Year < 2005 ~ "2000-2004",
    Year >= 2005 & Year < 2010 ~ "2005-2009",
    Year >= 2010 & Year < 2015 ~ "2010-2014",
    Year >= 2015 & Year < 2020 ~ "2015-2019",
    Year >= 2020 & Year <= 2023 ~ "2020-2023",
    TRUE ~ NA_character_  # For years outside the specified range
  )) %>%
  # Create age groups
  mutate(AgeGroup = case_when(
    Age >= 18 & Age <= 35 ~ "18-35",
    Age > 35 & Age <= 50 ~ "36-50",
    Age > 50 & Age <= 65 ~ "51-65",
    TRUE ~ ">65"
  )) %>%
  # Categorize Civil status
    mutate(MarriedOrPartner = case_when(
    Civil %in% c("G", "RP") ~ "Partner",  # Married or Registrerad Partner
    Civil %in% c("OG", "S", "Ä", "SP", "EP") ~ "Single",  # Other categories (you can specify these)
    TRUE ~ NA_character_  # Assign NA to cases that do not match any condition
  )) %>% 
  # Categorize Birth country
  mutate(BirthPlace = case_when(
    FodelseLandEU28 == "Sverige" ~ "Sweden",
    FodelseLandEU28 %in% c("EU utom Norden", "Europa utom EU och Norden", "Norden utom Sverige") ~ "In Europe",
    FodelseLandEU28 %in% 'Okänt'  ~ NA_character_,
    TRUE ~ "Outside Europe"
  )) %>%
  # Categorize Kommun based on hypothetical population size categories
  mutate(KommunSize = case_when(
    Kommun %in% metropolitan_municipalities ~ "metropolitan_municipalities",
    Kommun %in% dense_municipalities ~ "dense_municipalities",
    Kommun %in% rural_municipalities ~ "rural_municipalities",
    TRUE ~ NA_character_
  )) %>%

  # Categorize education level
  mutate(EducationLevel = case_when(
    SUN2000Niva_Old %in% 1:2 ~ "Primary",
    SUN2000Niva_Old %in% 3:4 ~ "Secondary",
    SUN2000Niva_Old %in% 5 ~ "Tertiary <2 years",
    SUN2000Niva_Old %in% 6:7 ~ "Higher Education",
    TRUE ~ NA_character_
  )) %>% 
    # Divide income into quartiles
  mutate(IncomeQuartile = ntile(CSFVI, 4), 
         .by = Period) %>%
   mutate(IncomeLevel = case_when(
    CSFVI >= 2 * median(CSFVI) ~ "≥200%",
    CSFVI >= 1.2 * median(CSFVI) & CSFVI < 2 * median(CSFVI) ~ "120–199%",
    CSFVI >= 0.8 * median(CSFVI) & CSFVI < 1.2 * median(CSFVI) ~ "80–119%",
    CSFVI >= 0.6 * median(CSFVI) & CSFVI < 0.8 * median(CSFVI) ~ "60–79%",
    CSFVI < 0.6 * median(CSFVI) ~"<60%",
    TRUE ~ NA_character_
  ), .by = Period) %>% 
  # combine occupation
    mutate(
  SSYK1_scb_hpi_combined = coalesce(SSYK1, Ssyk1_hpi_combined),
  # Categorize occupation
    SSYK_WB = case_when(SSYK1_scb_hpi_combined <= 4 ~ "White-Collar",
                             SSYK1_scb_hpi_combined > 4 ~ "Blue-Collar"),
SSYK_Category = case_when(
    SSYK1_scb_hpi_combined %in% 1:3 ~ "High-Skilled",                        # High-skilled group
    SSYK1_scb_hpi_combined %in% 4:5 ~ "Clerical and Service Workers",        # Clerical and service workers group
    SSYK1_scb_hpi_combined %in% 6:8 ~ "Skilled Manual",        # Skilled manual or blue-collar group
    SSYK1_scb_hpi_combined == 9 ~ "Elementary Occupations"                   # Elementary occupations group
),
SSYK1_scb_hpi_combined = case_when(
    SSYK1_scb_hpi_combined == "0" ~ "Armed forces occupations",
    SSYK1_scb_hpi_combined == "1" ~ "Managers",
    SSYK1_scb_hpi_combined == "2" ~ "Occupations requiring advanced level of higher education",
    SSYK1_scb_hpi_combined == "3" ~ "Occupations requiring higher education qualifications or equivalent",
    SSYK1_scb_hpi_combined == "4" ~ "Administration and customer service clerks",
    SSYK1_scb_hpi_combined == "5" ~ "Service, care and shop sales workers",
    SSYK1_scb_hpi_combined == "6" ~ "Agricultural, horticultural, forestry and fishery workers",
    SSYK1_scb_hpi_combined == "7" ~ "Building and manufacturing workers",
    SSYK1_scb_hpi_combined == "8" ~ "Mechanical manufacturing and transport workers, etc.",
    SSYK1_scb_hpi_combined == "9" ~ "Elementary occupations",
    TRUE ~ SSYK1_scb_hpi_combined # Keeps the original value if none of the above conditions are met
  ),
SNI = case_when(
    SNI == "A" ~ "Agriculture, forestry and fishing",
    SNI == "B" ~ "Mining and quarrying",
    SNI == "C" ~ "Manufacturing",
    SNI == "D" ~ "Electricity, gas, steam and air conditioning supply",
    SNI == "E" ~ "Water supply; sewerage, waste management and remediation activities",
    SNI == "F" ~ "Construction",
    SNI == "G" ~ "Wholesale and retail trade; repair of motor vehicles and motorcycles",
    SNI == "H" ~ "Transportation and storage",
    SNI == "I" ~ "Accommodation and food service activities",
    SNI == "J" ~ "Information and communication",
    SNI == "K" ~ "Financial and insurance activities",
    SNI == "L" ~ "Real estate activities",
    SNI == "M" ~ "Professional, scientific and technical activities",
    SNI == "N" ~ "Administrative and support service activities",
    SNI == "O" ~ "Public administration and defence; compulsory social security",
    SNI == "P" ~ "Education",
    SNI == "Q" ~ "Human health and social work activities",
    SNI == "R" ~ "Arts, entertainment and recreation",
    SNI == "S" ~ "Other service activities",
    SNI == "T" ~ "Activities of households as employers; undifferentiated goods- and services-producing activities of households for own use",
    SNI == "U" ~ "Activities of extraterritorial organisations and bodies",
    TRUE ~ SNI # Keeps the original value if none of the above conditions are met
  ),
BMI_cat = case_when(BMI > 25 & BMI < 30 ~ ">25",
                    BMI > 30 ~ ">30",
TRUE ~ "<=25"),
astr_cat = if_else(Astrand_rel_VO2 > 32, ">32", "<32"),
SNI = substr(IndustryCodeTopSNI2007, 1, 1)
 ) %>% 
  # factors
   mutate(
    EducationLevel =
      factor(EducationLevel,
             levels = c("Higher Education", "Tertiary <2 years", "Secondary", "Primary", "Unknown")),
    KommunSize =
      factor(KommunSize,
             levels = c("rural_municipalities", "dense_municipalities", "metropolitan_municipalities", "Other")),
    MarriedOrPartner =
      factor(MarriedOrPartner,
             levels = c("Partner", "Single")),
    BirthPlace = 
      factor(BirthPlace, 
             levels = c("Sweden", "In Europe", "Outside Europe")),
    IncomeLevel =
      factor(IncomeLevel,
             levels = c("≥200%", "120–199%", "80–119%", "60–79%", "<60%")),
        SSYK_Category =
      factor(SSYK_Category,
             levels = c("High-Skilled", "Skilled Manual", "Clerical and Service Workers", "Elementary Occupations")),
    factor(SSYK1_scb_hpi_combined, levels = c(
    "Armed forces occupations",
    "Managers",
    "Occupations requiring advanced level of higher education",
    "Occupations requiring higher education qualifications or equivalent",
    "Administration and customer service clerks",
    "Service, care and shop sales workers",
    "Agricultural, horticultural, forestry and fishery workers",
    "Building and manufacturing workers",
    "Mechanical manufacturing and transport workers, etc.",
    "Elementary occupations"
  )),
  SNI = factor(SNI, levels = c(
    "Agriculture, forestry and fishing",
    "Mining and quarrying",
    "Manufacturing",
    "Electricity, gas, steam and air conditioning supply",
    "Water supply; sewerage, waste management and remediation activities",
    "Construction",
    "Wholesale and retail trade; repair of motor vehicles and motorcycles",
    "Transportation and storage",
    "Accommodation and food service activities",
    "Information and communication",
    "Financial and insurance activities",
    "Real estate activities",
    "Professional, scientific and technical activities",
    "Administrative and support service activities",
    "Public administration and defence; compulsory social security",
    "Education",
    "Human health and social work activities",
    "Arts, entertainment and recreation",
    "Other service activities",
    "Activities of households as employers; undifferentiated goods- and services-producing activities of households for own use",
    "Activities of extraterritorial organisations and bodies"
  ))
  )
  

```

# Flowchart and data in/ex-clusion

```{r}

# global options for dtrackr

old = options(
 #dtrackr.strata_glue="{.group}:{.value}",
  #dtrackr.strata_sep="; ",
  dtrackr.strata_glue="{tolower(.value)}",
  dtrackr.strata_sep=", ",
  dtrackr.default_message = "n={formatC(.count, big.mark = ',',format = 'fg')}"
  #dtrackr.default_headline = "subgroup: {.strata}"
)
# reset options 
#options(old)

df2 <-
df1 |> 
  track(.headline = "Flow chart     ",
        .messages="Data SCB variables in HPI data"
  ) %>%
  status(.messages = "n={formatC(.count, big.mark = ',')}") %>%  
  filter(rowSums(!is.na(select(., EkB_rel_VO2, Astrand_rel_VO2, HeightCM, WeightKG, BloodPressureSystolic, BloodPressureDiastolic))) >= 2,
         rowSums(!is.na(select(., ExerciseAnswer, TobaccoSmoking, Diet, Health, StressOverall, SymptomBackNeck))) >= 2, 
         .messages = "Excluded {formatC(.excluded, big.mark = ',',format = 'fg')}", .headline = "questionnaire 2 physilogical 2" ) %>% 
   status(.messages = "n={formatC(.count, big.mark = ',')}") %>% 
  exclude_all(
    Year < 1995 ~ "{formatC(.excluded, big.mark = ',',format = 'fg')} Year < 1995",
    CSFVI == 0 ~ "{formatC(.excluded, big.mark = ',',format = 'fg')} with income 0kr",
   # Age > 65 ~  "{formatC(.excluded, big.mark = ',',format = 'fg')} with age > 65" ,
   # is.na(SSYK1_scb_hpi_combined) ~  "{formatC(.excluded, big.mark = ',',format = 'fg')} with NA in SSYK" ,
   # is.na(Civil) ~  "{formatC(.excluded, big.mark = ',',format = 'fg')} with NA in Civil",
  #  FodelseLandEU28=="Okänt" ~  "{formatC(.excluded, big.mark = ',',format = 'fg')} with 'Okänt'in fodelselandEU28",
   # SUN2000Niva_Old=="*" ~  "{formatC(.excluded, big.mark = ',',format = 'fg')} with NA in education (*)"
  ) %>% 
  status(.messages = "n={formatC(.count, big.mark = ',')}") %>% 
      arrange(LopNr, Performed) %>% 
  mutate(hpa_number = row_number(), 
         test_count = n(), .by = LopNr) %>% 
  filter(hpa_number == 1,
         .messages = "Excluded {formatC(.excluded, big.mark = ',',format = 'fg')}", .headline = "Repeated tests") %>% 
 # status() %>% 
  group_by(test_count>1,) %>% 
  comment(" has {formatC(.count, big.mark = ',')} items") %>%
  ungroup(.headline = "Total study population\nn={formatC(.count, big.mark = ',')}",
          .messages = "") 



df2 %>% flowchart()

df2 <- df2 %>% as_tibble()
#df1 |> 
 # flowchart(filename="testtype",
  #          formats = c("png","svg", "pdf"),
   #                      maxWidth=20, 
    #                    maxHeight = 20)


```

#-------------------------

# Function for creating table 1
sum_table.fun(df, val, group, gr_order, stat_type)

df- data frame.  
val- vector of character names c("xx","xxx").   
group- grouping variable.  
gr_order-order of the grouping variable options.  
stat_type-uncertainty-for continuous vars, options: mean_ci, mean_sd, median_q1q3, median_range.   
```{r Table functions}
# test statistics
# continuous multi group: anova/Kruskal  (parametric/non-parametric)
# continuous one or two group: t-test/Man-Whitney U (parametric/non-parametric)
# categorical two or more groups: Pearson's chi-squared or Fisher’s exact test or 
# Monte Carlo simulation approach, which is an approximate method.
# if any of the expected frequencies are < 5 in the contingency table

# https://www.saem.org/about-saem/academies-interest-groups-affiliates2/cdem/for-students/cdem-voice/educational-research-column/educational-research-column-choosing-wisely-chi-square-vs.-fisher-s-exact

# https://statsandr.com/blog/chi-square-test-of-independence-in-r/#chi-square-test-of-independence-in-r

###################
# FACTOR FUNCTION #
###################
# df <- t2
# var <- sym("Age")
# var <- sym("EducationLevel")
# group <- sym("Period")


# d <- factor.fun(df, Contraception, ModifiedM4)
# d <- factor.fun(df, BV_Diagnosis_v3, ModifiedM4) 
# d <- factor.fun(df, `Below LLD Estradiol`, Contraception) 
factor.fun <- function(df, var, group){
  var <- enquo(var)
  group <- enquo(group)
  
round.fun <- function(x) {
  sapply(x, function(y) {
    if(y >= 10) {
      round(y, digits = 0)
    } else if(y >= 0 & y < 10) {
      sprintf("%.1f", round(y, digits = 1))
    } else {
      formatC(y, format = "e", digits = 1)
    }
  })
}
  
  contingency.table <- df %>%
    select(!!var, !!group) %>%
    table() 
    
  # Pearson’s Chi-squared test:
  test <- chisq.test(contingency.table)
  t <- "2"
  
  # Fisher’s exact test but with Monte Carlo simulation approach, which is an approximate method.
  if(min(test$expected)<5)
    {test <- fisher.test(contingency.table, simulate.p.value = TRUE, B = 20000)
    t <- "4"}
    
  p.val <- test[["p.value"]] #%>% formatC(., format = "e", digits = 1) %>% paste0("$$ ",.,"^2 $$")
  if(p.val == ""){p.val <- NA}
    else if(p.val < 0.01){p.val <- "<0.01"}
      else{p.val <- sprintf(p.val, fmt = '%#.2f')}
  
  
  na <- sum(is.na(pull(df, !!var)))
  tab <- tibble("Variables"=as_label(var),"na"=as.numeric(na), "p-value"=p.val) #as.numeric(p.val)
  
  # mean, min and max:
  sum_tab <- df %>%
    select(!!var, !!group) %>%
    group_by(!!group, !!var) %>%
    summarize(n = n(), .groups = "drop_last") %>%
    nest() %>%
    ungroup() %>%
    mutate(sum = map(data, ~sum(.$n))) %>%
    unnest(c(data, sum)) %>%
    mutate(percent = round.fun(100*(n/sum))) %>% 
    mutate( val = paste0(format(.$n, big.mark = ",")," (",.$percent,"%)")) %>% # !!as_label(var) :
    select(-sum, -n, -percent) %>%
    pivot_wider(., names_from = (!!group), values_from = val ) %>%
    dplyr::rename(Variables = as_label(var)) %>%
    arrange(Variables) %>%
    mutate_at(vars(Variables), ~replace(as.character(.), is.na(.), "Not available")) %>%
    mutate_at(vars(Variables), ~paste0("  - ", .)) %>%
    mutate_if(is.character, ~replace(., is.na(.), 0))

   t <- bind_rows(tab, sum_tab) %>% mutate("t" = t)
  
  return(t)
  #return(sum_tab)
  #return(list(tab, na, p.val, sum_tab))
}



#######################
# CONTINUOUS FUNCTION #
#######################
# d_ <- continuous.fun(df, Age, Period)
# d_ <- continuous.fun(df2, Astrand_MaxVO2, Period, "mean_ci")
#d_ <- continuous.fun(df2, Health, Period, "mean_ci")
continuous.fun <- function(df, var, group, stat_type){
  var <- enquo(var)
  group <- enquo(group)
  name_g <- as_label(group) 
  name_v <- as_label(var) 
  
  # round decimals
round.fun <- function(x) {
  df <- x %>%
    mutate(across(.cols = "percent", 
                  ~ ifelse(.x >= 10, 
                           round(.x, digits = 0),  
                           ifelse(.x >= 0 & .x < 10, 
                                  sprintf("%.1f",round(.x, digits = 1)),
                                  formatC(.x, format = "e", digits = 1))))) %>%
    mutate(across(where(~ is.numeric(.) && !identical(names(.), "percent")), 
                  ~ ifelse(.x >= 1 | .x == 0, 
                           round(.x, digits = 1),
                           ifelse(.x >= 0.01 & .x <= 0.9, 
                                  round(.x, digits = 1),
                                  formatC(.x, format = "e", digits = 1)))))
  return(df)
}

#### Helper function for numeric summary (mean and 95% CI) ####
#  mean_confidence.fun <- function(m, se) {
#     ci_lower <- m - 1.96 * se
#     ci_upper <- m + 1.96 * se
# 
#     # Check if the variable is 'Astrand_MaxVO2'
#     if({{var}} == "Astrand_MaxVO2") {
#         # Do not round for 'Astrand_MaxVO2'
#         return(sprintf("%s (%s-%s)", m, ci_lower, ci_upper))
#     } else {
#         # Round to 2 decimal places for other variables
#         ci_lower <- round(ci_lower, 2)
#         ci_upper <- round(ci_upper, 2)
#         return(sprintf("%.1f (%.1f-%.1f)", m, ci_lower, ci_upper))
#     }
# } 
#### ####
  
  mean_confidence.fun <- function(m, se) {
    m <- m
    se <- se
    ci_lower <- round(m - 1.96 * se, 2)
    ci_upper <- round(m + 1.96 * se, 2)
    #ci_lower <- m - 1.96 * se
    #ci_upper <- m + 1.96 * se
     return(sprintf("%.1f (%.1f-%.1f)", m, ci_lower, ci_upper)) # 1 decimal place rounding
  }
 
  # make factors
  if( is.null(levels(group)) ){df <- mutate( df, !!(name_g) := factor((!!group)) ) }

  # p-value
  exp1 <- expr(!!ensym(var) ~ !!ensym(group))
  if( length(unique(pull(df, !!group))) > 2 ){
    test <- kruskal.test(formula = eval(exp1), data = df) 
    p.val <- test[["p.value"]]
    if(p.val < 0.01){p.val <- "<0.01"}else{p.val <- sprintf(p.val, fmt = '%#.2f')}
    t <- "3"
  }else{
    lvl <- df %>% select(!!var, !!group) %>% na.omit() %>% pull(., (!!group)) %>% unique() %>% length()
    if(lvl == 2){
    test <- wilcox.test(formula = eval(exp1), data = df)
    p.val <- test[["p.value"]]
    if(p.val < 0.01){p.val <- "<0.01"}else{p.val <- sprintf(p.val, fmt = '%#.2f')}
    t <- "1"}
    if(lvl < 2) {
      p.val <- NA
      t <- "5"
    }
  }
  l <- unique(pull(df, !!group))
  #l <- c("DMPA", "no HC")
  
  # mean, min max or similar
  #if(stat_type == "median")else{stat_type == "mean"}
  sum_tab <- df %>%
    select(!!var, !!group) %>%
    mutate(na = sum(is.na(!!var))) %>%
    group_by(!!group) %>%
    summarize(median = median((!!var),na.rm = T),
              mean = mean((!!var),na.rm = TRUE),
              se = sd((!!var), na.rm = TRUE) / sqrt(sum(!is.na((!!var)))),
              sd = sd((!!var), na.rm = TRUE),
              min = min((!!var),na.rm = T),
              max = max((!!var),na.rm = T),
              IQR = IQR((!!var), na.rm = TRUE),
              Q1 = quantile((!!var), probs = 0.25, na.rm = TRUE),
              Q3 = quantile((!!var), probs = 0.75, na.rm = TRUE),
              "  - Not available" = sum(is.na(!!var)),
              n = n(),
              .groups = "drop") %>% # d <- d_
    # mean(ci), median(icr) or median(range)
    mutate(percent = 100 * (`  - Not available` / n)) %>%
    mutate("  - Not available" = formatC(.$`  - Not available`, format="d", big.mark = ",")) %>%
    {. ->> temp} %>%
    {if ({{stat_type}} == "mean_ci") {
      mutate(., {{ var }} := pmap_chr(., ~mean_confidence.fun(..3, ..4)))
    } else .} %>%
    {if ({{stat_type}} == "mean_sd") {
      mutate(., {{ var }} := sprintf("%.1f (%.1f)", mean, sd))
    } else .} %>%
    {if ({{stat_type}} == "median_q1q3") {
      mutate(., {{ var }} := paste0(median, " (", Q1, "-", Q3, ")"))
    } else .} %>%
    {if ({{stat_type}} == "median_range") {
      mutate(., {{ var }} := paste0(median, " (", min, "-", max, ")"))
    } else .} %>%
    round.fun() %>%
    mutate("  - Not available" = paste0(.$`  - Not available`," (",.$percent,"%)")) %>%
    mutate_at(vars(`  - Not available`), str_replace_all, pattern = "^0 \\(0%\\)", replacement = "0") %>%
    select(!!group, !!as_label(var), `  - Not available`) %>%
    #dplyr::rename(., !!(var) :="val" ) %>%
    pivot_longer(-!!group, names_to='Variables', values_to='value') %>%
    pivot_wider(names_from = !!group, values_from = value) %>%
    mutate("p-value" = c(p.val, NA)) %>%
    mutate(na = c( sum(is.na(pull(df, !!var))), NA )) %>%
    filter(!if_all(all_of(l), ~grepl("^0$", .) & Variables == "  - Not available")) %>%
    mutate_if(is.character, str_replace_all, pattern = "NA \\(Inf--Inf\\)", replacement = "NA (NA)") %>%
    mutate("t" = t)

  return(sum_tab)
  #return(list(exp1, df, lvl=lvl))
}   

###########################
# COMBINE TABLES FUNCTION #
###########################
# gr_order <- c("NonIners", "Iners", "Gard", "Prev", "Oth")
# d_ <- sum_table.fun(metadata, val, ModifiedM4, gr_order)
# a <- sum_table.fun(meta_all, val, Contraception, gr_order)
sum_table.fun <- function(df, val, group, gr_order, stat_type ) {
  group <- enquo(group)
  
  # round decimals
  round.fun <- function(x){
    df <- x %>%
    mutate_if(
    is.numeric,
    ~ ifelse(.x >= 1|.x==0, round(.x, digits = 0),
            ifelse(.x< 1 & .x >= 0.001, round(.x, digits = 2),
                                          "< 0.001")))
  }
  c <- c()
  f <- c()
  
  for (v in val) {
    if(is.numeric( pull(df, v))) 
      {c<-c(c, v)}
    else{f<-c(f, v)}
  } 
  
  # count (n) in each group
  count <- table( pull(df, !!group) ) 
  #count_t <- count %>% paste0("**",names(.),"**","\\\n","n=(", ., ")") %>% set_names(., names(count))  
  count_t <- count %>% 
  format(big.mark = ",") %>%
    # markdown
  #paste0("**", names(.), "**", "\\\n", "n=(", ., ")") %>%
    # html
  paste0("<b>", names(.), "</b>", "<br>", "(n=", ., ")") %>%
  set_names(., names(count))
  names_n <- names(count) %>% set_names(., count_t)
  
  l_c <- imap(c, ~continuous.fun(stat_type=stat_type, df=df, var=!! rlang::sym(.x), group=(!!group)) ) %>%
    bind_rows(., )
  l_f <- imap(f, ~factor.fun(df, !! rlang::sym(.x), (!!group)) ) %>%
    bind_rows(.)
  
  table <- bind_rows(l_c, l_f) %>%
    round.fun() %>%
    mutate("p-value" = ifelse(is.na(.$`p-value`),NA, paste0("$$ ",.$`p-value`,"^",.$t," $$"))) %>%
    select("Variables", any_of(gr_order), "p-value", "na", -t) %>%
    mutate_at(vars("na"), ~ as.character(.)) %>%
    dplyr::rename(!!! names_n) %>%
    dplyr::rename("**p-value**"=`p-value`, "<b>Not available</b>"='na')

  #return(list(l_c, l_f, table))
  return(table)
  
}
  


```

# Function for creating vs-tables

```{r}

### Function for calculate difference between percentages of categorical variables ####
# # for 
 # group_var <- sym("Period")
 # df1 %>% select({{group_var}})
 #  {.->>temp} %>%

# The relative_risk is calculated as the ratio of the percentage in df2 to the percentage in df1. It quantifies how much more (or less) common a category is in df2 compared to df1.


 calculate_percentages <- function(df, group_var, vars) {
  df %>%
    select({{ group_var }}, all_of(vars)) %>%
    pivot_longer(cols = -{{ group_var }}, names_to = "Variable", values_to = "Categories") %>%
    group_by({{ group_var }}, Variable, Categories) %>%
    summarize(n = n(), .groups = "drop_last") %>%
    group_by({{ group_var }}, Variable) %>%
    mutate(sum = sum(n)) %>%
    ungroup() %>%
    mutate(percent = 100 * (n / sum)) %>%
    select(-sum) 
 }

 
  compare_percentages <- function(df1, df2, group_var, vars) {
    
  df1_percentages <- calculate_percentages(df1, {{ group_var }}, vars)
  df2_percentages <- calculate_percentages(df2, {{ group_var }}, vars)

  inner_join(df1_percentages, df2_percentages,
by = join_by({{ group_var }}, Variable, Categories)) %>%    
    mutate(percent_diff = percent.x - percent.y) %>%  {.->>temp} %>%
    #select(-percent.x, -percent.y) %>%
    rename(Percent_df1 = percent.x, 
           Percent_df2 = percent.y, 
           n_df1 = n.x,
           n_df2 = n.y,
           Variable = Variable, 
           Categories = Categories)
 }
 
  

  
  
  ## with if condition
  calculate_percentages <- function(df, vars, group_var = NULL) {
  # Check if group_var is provided and is a valid column name
  if (!is.null(group_var) && group_var %in% names(df)) {
    # Processing when group_var is provided and valid
    df %>%
      select(.data[[group_var]], all_of(vars)) %>%
      pivot_longer(cols = -all_of(group_var), names_to = "Variable", values_to = "Categories") %>%
      group_by(.data[[group_var]], Variable, Categories) %>%
      summarize(n = n(), .groups = "drop_last") %>%
      group_by(.data[[group_var]], Variable) %>%
      mutate(sum = sum(n)) %>%
      ungroup() %>%
      mutate(percent = 100 * (n / sum)) %>%
      select(-sum)
  } else {
    # Processing when group_var is not provided or not valid
    df %>%
      pivot_longer(cols = all_of(vars), names_to = "Variable", values_to = "Categories") %>%
      count(Variable, Categories) %>%
      group_by(Variable) %>%
      mutate(percent = 100 * n / sum(n)) %>%
      ungroup() 
  }
}

 # calculate_percentages(df2, vars = c("AgeGroup", "Sex"), group_var = Period)
  
  compare_percentages <- function(df1, df2, group_var, vars) {
    
  df1_percentages <- calculate_percentages(df1, vars, group_var)
  df2_percentages <- calculate_percentages(df2, vars, group_var)

  inner_join(df1_percentages, df2_percentages, by = c("Variable", "Categories", group_var)) %>%    
    mutate(percent_diff = percent.x - percent.y,
           relative_risk = percent.y / percent.x) %>%
    # select(-percent.x, -percent.y) %>%
    rename(Percent_df1 = percent.x, 
           Percent_df2 = percent.y, 
           n_df1 = n.x,
           n_df2 = n.y,
           Variable = Variable, 
           Categories = Categories)
}
 
  
  
  compare_percentages <- function(df1, df2, group_var, vars) {
    
  df1_percentages <- calculate_percentages(df1, vars, group_var)
  df2_percentages <- calculate_percentages(df2, vars, group_var)

  joined_data <- inner_join(df1_percentages, df2_percentages, by = c("Variable", "Categories", group_var)) %>%
    mutate(
percent_diff =  percent.y -percent.x,
           relative_risk = percent.y / percent.x,
      # Estimate total counts
      total_df1 = n.x / (percent.x / 100),
      total_df2 = n.y / (percent.y / 100),
      # Calculate log of relative risk
      log_rr = log(relative_risk),
      # Calculate standard error of log relative risk

      se_log_rr = sqrt((1/n.x - 1/total_df1) + (1/n.y - 1/total_df2))
    )

  # For a 95% confidence interval
  z_score <- qnorm(0.975) # Approximately 1.96
  joined_data %>%
    mutate(
      ci_lower = exp(log_rr - z_score * se_log_rr),
      ci_upper = exp(log_rr + z_score * se_log_rr),
      rr_with_ci = sprintf("%.2f (%.2f-%.2f)", relative_risk, ci_lower, ci_upper),
      n_and_percent_df1 = sprintf("%d (%.1f%%)", n.x, percent.x),
      n_and_percent_df2 = sprintf("%d (%.1f%%)", n.y, percent.y),
      p_diff = sprintf("%.1f%%", percent_diff)
    ) %>%
    select(-log_rr, -se_log_rr, -total_df1, -total_df2) %>%
    rename(
      Percent_df1 = percent.x, 
      Percent_df2 = percent.y, 
      n_df1 = n.x,
      n_df2 = n.y,
      Variable = Variable, 
      Categories = Categories
    )
}

  
```



#-------------------------
# Descriptive tables




## -Table 1. Lifestyle characteristics
Inte helt färdig men tilltänkt info finns med i tabellen. 
```{r}


    
val_use <- 
  colnames(
  df2 %>%
    select(HeightCM, WeightKG, BMI, EkB_rel_VO2, Astrand_MaxVO2, Astrand_rel_VO2, BMI_cat, astr_cat,TobaccoSmoking, Health, ExerciseAnswer, PhysicalWorkSituation))
to_char <- c("TobaccoSmoking", "BMI_cat", "astr_cat", "Health", "ExerciseAnswer", "PhysicalWorkSituation")

t1 <- 
df2 %>% 
  select(Period, any_of(val_use)) %>% 
  mutate(across(any_of(to_char), ~as.character(.))) %>%
  
  sum_table.fun(., 
                val = val_use,
                group = Period,
                stat_type = "mean_sd", # for numerical
                gr_order =  c("1995-1999", "2000-2004", "2005-2009", "2010-2014", "2015-2019", "2020-2023")) #unique(df2$Period))


t1  <-
t1 %>% 
  mutate(Variables = case_when(
    Variables == "HeightCM" ~ "Height cm, Mean (SD)",
    Variables == "WeightKG" ~ "Weight kg, Mean (SD)",
    Variables == "BMI" ~ "BMI, Mean (SD)",
    Variables == "astr_cat" ~ "VO2max, n (%)",
    Variables == "TobaccoSmoking" ~ "Smoking, n (%)",
    TRUE ~ Variables  
  ))

# Skapa en DataTable från den sammanfogade datan
   t1 %>% 
     mutate(Variables = ifelse(grepl("  -.+|^ $", .$Variables), 
                            .$Variables, paste0("<b>",.$Variables,"</b>")) ) %>% select( -`**p-value**`) %>% 
datatable(
  escape = FALSE,  # to render HTML
  extensions = 'Buttons',
  options = list(
    scrollX = TRUE,
    pageLength = 50,
    lengthMenu = list(c(5, 10, 30, 50, -1), c('5', '10', '30', '50', 'All')),
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    title = "Sammanställd Frekvens av ICD-koder",
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '10px'});",
      "$(this.api().table().body()).css({'font-size': '10px'});",
      "}"
    )
  ),
  class = "compact" # This class reduces padding/margin in the table
)

# flextable(t1)

```
pander
```{r eval=FALSE}
library(pander)
gr_order =  c("1995-1999", "2000-2004", "2005-2009", "2010-2014", "2015-2019", "2020-2023")

s <- c(" ", rep(c("mean (CI)"), times=length(gr_order)), NA, NA) %>% set_names(., colnames(t1))

a_ <- bind_rows(s, t1) %>% 
  mutate(Variables = ifelse(grepl("  -.+|^ $", .$Variables), 
                            .$Variables, paste0("**",.$Variables,"**")) ) #%>%
  #select(-`**na**`, -`**p-value**`) #%>%
  #column_to_rownames(var = "Variables")

pander(a_, keep.line.breaks = TRUE, split.table = Inf) 

  
```

#-------------------------
  
# Sociodemographics. 

## -Table 2. Sociodemographics  

```{r}
to_char <- c("SSYK1_scb_hpi_combined")

val_use <- 
  colnames(
  df2 %>% select(
    Sex, AgeGroup, BirthPlace, MarriedOrPartner, EducationLevel, KommunSize, SSYK1_scb_hpi_combined
    )
  )



t2 <- df2 %>% 
  select(Period, any_of(val_use)) %>% 
  mutate(across(any_of(to_char), ~as.character(.))) %>%
  sum_table.fun(., 
                val = val_use,
                group = Period,
                stat_type = "mean_ci",
                gr_order =  c("1995-1999", "2000-2004", "2005-2009", "2010-2014", "2015-2019", "2020-2023")) #unique(df2$Period))

t2  <-
t2 %>% 
  mutate(Variables = case_when(
    Variables == "AgeGroup" ~ "Age group, n (%)",
    Variables == "EducationLevel" ~ "Education, n (%)",
    Variables == "KommunSize" ~ "Municipality, n (%)",
    Variables == "MarriedOrPartner" ~ "Partner, n (%)",
    Variables == "BirthPlace" ~ "Nativity, n (%)",
    Variables == "SSYK1_scb_hpi_combined" ~ "Occupation, major level, n (%)",
    TRUE ~ Variables  
  ))
# df <- df %>%
#   mutate(column_name = if_else(row_number() >= 20 & row_number() <= 23, 9, column_name))

  t2 %>% 
     mutate(Variables = ifelse(grepl("  -.+|^ $", .$Variables), 
                            .$Variables, paste0("<b>",.$Variables,"</b>")) ) %>% 
    select( -`**p-value**`) %>% 
datatable(
  escape = FALSE,  # to render HTML
  extensions = 'Buttons',
  options = list(
    scrollX = TRUE,
    pageLength = 40,
    lengthMenu = list(c(5, 10, 30, 50, -1), c('5', '10', '30', '50', 'All')),
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    title = "Sammanställd Frekvens av ICD-koder",
        columnDefs = list(
      list(className = 'dt-body-right', targets = 2:8) # Target columns 2 to 7 -rightalign
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '10px'});",
      "$(this.api().table().body()).css({'font-size': '10px'});",
      "}"
    )
  ),
  class = "compact" # This class reduces padding/margin in the table
)

```

## -Figure 1. Sociodemographics - SCB vs HPI data  
Percentage point differences for year groups and total  
**EJ RIKTIG DATA**


```{r out.width="100%", fig.height=7.5}



library(statebins)
library(ggtext)
library(patchwork)
library(sysfonts)
library(showtextdb)
library(showtext)
library(ggchicklet)
# Load fonts --------------------------------------------------------------

font_add_google("Ubuntu", "ubuntu")
showtext_auto()

bg_col <- "white"
text_col <- "black"
body_font <- "ubuntu"
title_font <- "ubuntu"





# Extract the colors from the 'lipari' palette
# colors <- scico::scico(n = n_colors, palette = 'lipari')
# n_colors <- 9
# 
# c("#364B9A", "#4A7BB7", "#6EA6CD", "#98CAE1", "#C2E4EF", "white", "#FEDA8B", "#FDB366", "#F67E4B", "#DD3D2D", "#A50026")
# # Print the colors
# colors
# "#021326" "#1E4368" "#5C5D78" "#89606E" "#C2655F" "#EA8D6B" "#E6BC91" "#FDF4D9"
#  "#021326" "#173D60" "#515A79" "#775E72" "#FDF4D9"  "#E6C398" "#E99973" "#D86E5D" "#A36267" 
#  
  plot_table <- 
   compare_percentages(
  df1 = df2 %>% filter(test_count == 1),
  df2 = df2 %>% filter(test_count > 1),
  group_var = "Period",
  vars =colnames(df2 %>% select(
    Sex, AgeGroup, BirthPlace, MarriedOrPartner, EducationLevel, KommunSize, IncomeLevel, SSYK_Category
    )
)
)

bins_plot <-
  ggplot(plot_table %>% mutate(z=scale(percent_diff),
                        abs = abs(percent_diff)),
   aes(x = Period, y = Categories, fill = percent_diff)
   ) +
  statebins:::geom_rtile(
    radius = unit(3, "pt"),
  #  position = position_dodge(1),
   height =.95, 
   width = .95
  ) +
   geom_text(aes(label = round(percent_diff,1))) +
  # scico::scale_fill_scico(palette = 'lipari') +
  # 
  # scale_fill_gradientn(colors = c(  "#ca9b1a", "#e3b44a", "#f5cc79", "#fae3ac", "#fdf1d6",
  # "white",
  # "#c4e2e1", "#88d4d2", "#4bc6c3", "#1ebbbf", "#189a91"),
  # values = scales::rescale(c(-1, 0, 1))) +
  
    scale_fill_gradientn(colors = c( "#173D60", "#515A79" ,"#775E72", "#FDF4D9",  "#E6C398", "#E99973",  "#A36267") ,
  values = scales::rescale(c(-1, 0, 1))) +
  scale_x_discrete(labels = c("95-00", "00-05", "05-10", "10-15", "15-20", "20-23", "-23"),
                   position = "top",
                   guide = guide_axis(n.dodge = 2)) + 
  #coord_fixed() +
  ggforce::facet_col(~Variable, 
                     scales = 'free_y', 
                     space = 'free',
                     strip.position = 'top')+
  #facet_wrap(~group, ncol = 1, scales = "free_y") +
  #theme_void(base_size = 32, base_family = "Oficial") +

  theme(
   # aspect.ratio = .2,
    
    legend.position = "bottom",
    plot.background = element_rect(fill = bg_col, colour = bg_col),
    panel.background = element_rect(fill = bg_col, colour = bg_col),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    axis.title = element_blank(),
    axis.text.y = element_text(colour = text_col,
                               hjust = 1,
                               margin = margin(r = 0),
                               angle=0),
    axis.text.x = element_text(colour = text_col,
                               hjust = .5,
                               margin = margin(r = 0),
                               angle=0),
    axis.line.x = element_line(),
    axis.ticks.x = element_line(),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    strip.text = element_text(face = "bold", color = "grey10", 
                              size = 10,
                              hjust = 0,
                              margin = margin(t = 0, r = 0, b = 0, l = 0)),
    strip.background = element_rect(fill = "white", color = "white"),
    plot.margin = margin(t=10, r=-0, b=10, l=0),
    plot.title = element_textbox_simple(
      colour = text_col,
      hjust = 0.5,
      halign = 0,
      size = rel(1.8),
      face = "bold",
      margin = margin(b = 10, t = 10),
      lineheight = 0.5#,
      #family = body_font
    )
  )

# marginal plot
bar_plot_data <- 
  plot_table %>% group_by(Variable, Categories) %>% 
  summarise(Value=mean(percent_diff))

bar_plot <- 
  ggplot(bar_plot_data, 
         aes(x = Categories, y = Value, fill = Value)) +

  geom_col( position = position_dodge(width = 1),
                # radius = grid::unit(3, "pt")
            ) +
  geom_hline(yintercept = 0, color = "grey") +
  coord_flip() +
  
    scale_fill_gradientn(colors = c(  "#173D60", "#515A79" ,"#775E72", "#FDF4D9",  "#E6C398", "#E99973", "#A36267"), 
                       values = scales::rescale(c(-1, 0, 1))) +
   scale_y_continuous(position = "left",
                    expand = waiver()) + 
#  theme_void() +
  labs(title = "Mean difference") +
   ggforce::facet_col(~Variable, 
                      scales = 'free_y', 
                      space = 'free',
                      strip.position = 'top') + 
 
    theme(
    plot.margin = margin(t=10, r=-10, b=10, l=10),
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    #axis.ticks.x= element_line(linewidth = 3, color = "black"),
    axis.ticks.y= element_blank(),
    axis.line.x = element_line(),
    axis.text.x = element_text(),
    axis.title = element_blank(),
    legend.position = "off",
    plot.background = element_rect(fill = bg_col, colour = bg_col),
    panel.background = element_rect(fill = bg_col, colour = bg_col),
    axis.text.y = element_blank(),
    plot.title.position = "plot",
    plot.title = element_text(hjust = 0.5),
    plot.caption.position = "plot",
    strip.text = element_text(color = "transparent",
                                margin = margin(t = 0, r = 0, b = 0, l = 0)),
    strip.background = element_rect(fill = "white", color = "white")
    )

# Combine the two plots
combined_plot <- bins_plot + bar_plot +
  plot_layout(widths = c(4, 2)) 

# Display the combined plot
combined_plot

```




## -Table 3. Sociodemographics  
Relative difference/risk between SCB and HPI data

```{r}
 rel_diff_table <- 
   compare_percentages(
  df1 = df2 %>% filter(test_count == 1),
  df2 = df2 %>% filter(test_count > 1),
  group_var = "Period",
  vars =colnames(df2 %>% select(
    Sex, AgeGroup, BirthPlace, MarriedOrPartner, EducationLevel, KommunSize, IncomeLevel, SSYK_Category
    )
)
)


rel_diff_table %>% 
  select(Period, Variable,Categories, rr_with_ci) %>% 
  pivot_wider(names_from=Period,
              values_from = rr_with_ci) %>% 
  
datatable(
  escape = FALSE,  # to render HTML
  extensions = 'Buttons',
  options = list(
    scrollX = TRUE,
    pageLength = 40,
    lengthMenu = list(c(5, 10, 30, 50, -1), c('5', '10', '30', '50', 'All')),
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    title = "Sammanställd Frekvens av ICD-koder",
        columnDefs = list(
      list(className = 'dt-body-right', targets = 3:8) # Target columns 2 to 7 -rightalign
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '10px'});",
      "$(this.api().table().body()).css({'font-size': '10px'});",
      "}"
    )
  ),
  class = "compact" # This class reduces padding/margin in the table
)
 
```


#-------------------------
  
# Worklife characteristics  

## -Table 4. Worklife characteristics  

**Possible additional variables**.  
Contractual relationship insecurity.  
Directly employed by the employer (0).  
Employed by an agency (-1) Combination of self- and direct employment (-1).   Self-employed (-1).  
Solo self-employed (-2).  
Contractual temporariness Stable employment (0) Unstable employment (-2).  
Multiple jobs/economic sectors.  
CBA coverage (% likelihood).  
https://isf.se/publikationer/rapporter/2018/2018-09-04-vem-far-avsattningar-till-tjanstepension
```{r}

to_char <- c("SSYK1_scb_hpi_combined")

val_use <- 
  colnames(
  df2 %>% select(
    IncomeLevel, SNI 
    ) 
    )
  

t3 <- df2 %>% 
  select(Period, any_of(val_use)) %>% 
  mutate(across(any_of(to_char), ~as.character(.))) %>%
 
  
  sum_table.fun(., 
                val = val_use,
                group = Period,
                gr_order =  c("1995-1999", "2000-2004", "2005-2009", "2010-2014", "2015-2019", "2020-2023")) #unique(df2$Period))


t3  <-
t3 %>% 
  mutate(Variables = case_when(
    Variables == "IncomeLevel" ~ "Percentage of median income, n (%)",
    Variables == "SSYK1_scb_hpi_combined" ~ "Occupation, major level, n (%)",
    TRUE ~ Variables  
  ))




# Skapa en DataTable från den sammanfogade datan
t3 %>% 
mutate(Variables = ifelse(grepl("  -.+|^ $", .$Variables), 
      .$Variables, paste0("<b>",.$Variables,"</b>")) ) %>% 
  select( -`**p-value**`) %>% 
datatable(
  escape = FALSE,  # to render HTML
  extensions = 'Buttons',
  options = list(
    scrollX = TRUE,
     pageLength = 30,
    lengthMenu = list(c(5, 10, 30, 50, -1), c('5', '10', '30', '50', 'All')),
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    title = "Sammanställd Frekvens av ICD-koder",
      columnDefs = list(
      list(className = 'dt-body-right', targets = 2:8) # Target columns 2 to 7 -rightalign
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '10px'});",
      "$(this.api().table().body()).css({'font-size': '10px'});",
      "}"
    )
  ),
  class = "compact" # This class reduces padding/margin in the table
)

```


## -Figure 2. Worklife characteristics - SCB vs HPI  

Percentage point differences for year groups and total  
EJ RIKTIG DATA

```{r out.width="100%", fig.height=7.5}
combined_plot
```

## -Table 5. Worklife characteristics
Relative difference/risk between SCB and HPI data




```{r}
 rel_diff_table <- 
   compare_percentages(
  df1 = df2 %>% filter(test_count == 1),
  df2 = df2 %>% filter(test_count > 1),
  group_var = "Period",
  vars =colnames(df2 %>% select(
    IncomeLevel, SNI 
    )
)
)


rel_diff_table %>% 
  select(Period, Variable,Categories, rr_with_ci) %>% 
  pivot_wider(names_from=Period,
              values_from = rr_with_ci) %>% 
  
datatable(
  escape = FALSE,  # to render HTML
  extensions = 'Buttons',
  options = list(
    scrollX = TRUE,
    pageLength = 40,
    lengthMenu = list(c(5, 10, 30, 50, -1), c('5', '10', '30', '50', 'All')),
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    title = "Sammanställd Frekvens av ICD-koder",
        columnDefs = list(
      list(className = 'dt-body-right', targets = 3:8) # Target columns 2 to 7 -rightalign
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '10px'});",
      "$(this.api().table().body()).css({'font-size': '10px'});",
      "}"
    )
  ),
  class = "compact" # This class reduces padding/margin in the table
)
```

#-------------------------


# 20 most underrepresented/overrepresented groups

Saknas data, vilka variabler är viktiga? yrke, kön, och ålder, privat/ej privat?

Sex,  age, occupation, privat/not private, country of birth
year period,education level, SSYK, sector, storlek på företag, region/municipality, country of birth, ekonomiskt resultat företag

## -Figure 3, waiting for SCB data

Hierarchical Clustering
```{r out.width="100%", fig.height=7.5}

library(tidyclust)
kmeans_spec <- k_means(num_clusters = 3) %>%
  set_engine("stats")

 kmeans_spec %>%
  fit(~., data = mtcars)

 
 d <-
plot_table %>% select(Period, Variable,Categories, percent_diff)%>%group_by(Variable, Categories) %>%  summarise(percent_diff=mean(percent_diff)) #%>% 
   # pivot_wider(names_from = Categories, values_from = percent_diff) %>% 
  print(n=44)






library(cluster)
# Assuming your data is in a dataframe called df
# Calculate the Gower distance matrix
gower_dist <- cluster::daisy(d[, c('Variable', 'Categories')], metric = "gower")

# Perform hierarchical clustering
hclust_res <- hclust(gower_dist, method = "ward.D2")

# Plot the dendrogram
plot(hclust_res)



library(ggdendro)
df   <- USArrests 
labs <- paste("veryverylongtitlename",1:50,sep="")
rownames(df) <- labs



hc       <- hclust(dist(df), "ave")           # heirarchal clustering
dendr    <- dendro_data(hc, type="rectangle") # convert for ggplot
clust    <- cutree(hc,k=2)                    # find 2 clusters
clust.df <- data.frame(label=names(clust), cluster=factor(clust))
# dendr[["labels"]] has the labels, merge with clust.df based on 
# label column
dendr[["labels"]] <- merge(dendr[["labels"]],clust.df, by="label")
# plot the dendrogram; note use of color=cluster in geom_text(...)
ggplot() + 
  geom_segment(data=segment(dendr), aes(x=x, y=y, xend=xend, 
yend=yend)) + 
  geom_text(data=label(dendr), aes(x, y, label=label, hjust=0, color=cluster), 
       size=3) +
  coord_flip() + scale_y_reverse(expand=c(0.2, 0)) + 
  theme(axis.line.y=element_blank(),
    axis.ticks.y=element_blank(),
    axis.text.y=element_blank(),
    axis.title.y=element_blank(),
    panel.background=element_rect(fill="white"),
    panel.grid=element_blank())

```
#-------------------------


# 1st vs 2ond test
percentage point difference and relative risk


## -Table 6. Difference between those with one test vs those with 2 or more tests at their first test.
```{r}
 result_table <- 
   compare_percentages(
  df1 = df2 %>% filter(test_count == 1),
  df2 = df2 %>% filter(test_count > 1),
  group_var = NULL,
  vars =colnames(df2 %>% select(
    Sex, AgeGroup, BirthPlace, MarriedOrPartner, EducationLevel, KommunSize, IncomeLevel, SNI
    )
)
)


 result_table %>% select(Variable, Categories, n_and_percent_df1, n_and_percent_df2, p_diff, rr_with_ci) %>% 
   mutate(across(where(is.numeric), round,1)) %>% 
datatable(
  escape = FALSE,  # to render HTML
  extensions = 'Buttons',
  options = list(
    scrollX = TRUE,
     pageLength = 62,
    lengthMenu = list(c(5, 10, 30, 50, -1), c('5', '10', '30', '50', 'All')),
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    title = "Sammanställd Frekvens av ICD-koder",
      columnDefs = list(
      list(className = 'dt-body-right', targets = 3:6) # Target columns 2 to 7 -rightalign
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '10px'});",
      "$(this.api().table().body()).css({'font-size': '10px'});",
      "}"
    )
  ),
  class = "compact" # This class reduces padding/margin in the table
)

 
 

   
```



```{r}




 result_table2 <- 
   compare_percentages(
  df1 = df2 %>% filter(test_count == 1)%>% 
  mutate(across(where(is.double), as.character)),
  df2 = df2 %>% filter(test_count > 1)%>% 
  mutate(across(where(is.double), as.character)),
  group_var = NULL,
vars = colnames(df2 %>% 
   select(BMI_cat, astr_cat,TobaccoSmoking, Health, ExerciseAnswer, PhysicalWorkSituation) %>% 
  mutate(across(where(is.double), as.character)))
)

result_table2%>% select(Variable, Categories, n_and_percent_df1, n_and_percent_df2, p_diff, rr_with_ci) %>% 
   mutate(across(where(is.numeric), round,1)) %>% 
datatable(
  escape = FALSE,  # to render HTML
  extensions = 'Buttons',
  options = list(
    scrollX = TRUE,
     pageLength = 62,
    lengthMenu = list(c(5, 10, 30, 50, -1), c('5', '10', '30', '50', 'All')),
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel'),
    title = "Sammanställd Frekvens av ICD-koder",
      columnDefs = list(
      list(className = 'dt-body-right', targets = 3:6) # Target columns 2 to 7 -rightalign
    ),
    initComplete = JS(
      "function(settings, json) {",
      "$(this.api().table().header()).css({'font-size': '10px'});",
      "$(this.api().table().body()).css({'font-size': '10px'});",
      "}"
    )
  ),
  class = "compact" # This class reduces padding/margin in the table
)

```


KAN även visas i graf form, men kanske räcker med en tabell för detta.


```{r out.width="100%", fig.height=7.5}
result_table %>% 
     ggplot(aes(x=percent_diff, y = Categories)) +
     geom_ribbon(aes(ymin = -Inf, ymax = Inf, xmin = -5, xmax = 5), fill = "pink", alpha = 1) +
     geom_vline(xintercept = 0, color = "grey") +
     geom_col(fill="lightblue") +
     xlim(c(-15,15))+
     geom_text(aes(x=12,label = n_df2), hjust=1) +
     geom_text(aes(x=-10,label = n_df1), hjust=1) +
     facet_wrap(~ Variable, scales = "free_y", ncol = 1) +
     labs(title = "those with one test vs those with two tests, those with only one test have higer % women") +
     theme_minimal() +
     theme(legend.position = "bottom")
```


#-------------------------


# other stuff not included in paper

## Income graph
```{r}

df1 %>%
  mutate(Period = case_when(
    Year >= 1995 & Year < 2000 ~ "1995-1999",
    Year >= 2000 & Year < 2005 ~ "2000-2004",
    Year >= 2005 & Year < 2010 ~ "2005-2009",
    Year >= 2010 & Year < 2015 ~ "2010-2014",
    Year >= 2015 & Year < 2020 ~ "2015-2019",
    Year >= 2020 & Year <= 2023 ~ "2020-2023",
    TRUE ~ NA_character_  # For years outside the specified range
  )) %>%
  ggplot(aes(x = Period, y = CSFVI)) + 
  geom_violin() +
  geom_boxplot(width = 0.2, 
                 outlier.color = "red",
  outlier.fill = "red",
  outlier.shape = 19,
  outlier.size = .3,
  outlier.stroke = 0.5,
  outlier.alpha = .8,
  position = position_dodge() )+  # Still hide outliers in boxplot for clarity
  #geom_jitter(color = "red", size = 1, width = 0.1, height = 0, aes(group = Period)) +  # Add jitter for outliers
  scale_y_log10(labels = scales::label_number(), breaks = scales::log_breaks(n = 20)) +  # More breaks on the y-axis
  theme_minimal() +
  labs(y = "CSFVI (log scale)", x = "Period")

```



* Uppgift saknas
1 Förgymnasial utbildning kortare än 9 år
2 Förgymnasial utbildning 9 år
3 Gymnasial utbildning högst 2-årig
4 Gymnasial utbildning 3 år
5 Eftergymnasial utbildning kortare än 3 år
6 Eftergymnasial utbildning 3 år eller längre (exkl. forskarutbildning)
7 Forskarutbildning 


High-Skilled Group:  
Managers and Administrators
Professionals (e.g., healthcare, education, IT)
Technicians and Associate Professionals
This group encompasses roles that typically require advanced education, specialized skills, and a high level of expertise.

Skilled Manual (Blue Collar) Group:  
Skilled Agricultural, Forestry, and Fishery Workers
Craft and Related Trades Workers
Plant and Machine Operators, and Assemblers
Jobs in this group generally require specific vocational skills or training, often involving manual labor or technical expertise.  


Clerical and Service Workers Group (Clerical Support Workers,   
Service and Sales Workers):  
This group covers roles primarily in the service sector, including both office-based clerical jobs and customer-facing service roles. These occupations may require certain levels of training and skills, but not to the extent of the high-skilled group.

Elementary Occupations:    
This group includes occupations that usually perform simple and routine tasks, which may require the use of hand-held tools and physical effort. These roles often do not require formal educational credentials or specialized training. 